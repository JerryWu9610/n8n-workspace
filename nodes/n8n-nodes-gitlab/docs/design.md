# 设计文档

## 1. 凭证与认证机制

为了同时满足连接固定 GitLab 实例和动态传入连接信息的需求，我们采用一种简洁的混合认证模式。

### 1.1 设计目标

- **安全性**: 默认情况下，`Access Token` 应被安全存储，避免在工作流执行日志中明文暴露。
- **易用性**: 对于连接单个 GitLab 实例的普通用户，通过选择预设凭证即可完成配置。
- **灵活性**: 对于需要在运行时动态决定 `Host` 和 `Access Token` 的高级用例，节点应提供直接输入的字段。

### 1.2 实现方案

1.  **创建凭证 (Credentials)**
    -   我们将创建一个名为 `gitlabApi` 的新凭证类型。
    -   该凭证包含两个字段：
        -   `host`: GitLab 实例的 URL (例如 `https://gitlab.com`)。
        -   `accessToken`: 用于 API 认证的个人访问令牌 (Personal Access Token)。
    -   n8n 会自动加密存储 `accessToken` 字段，确保其安全。

2.  **操作节点中的认证字段**
    -   在每一个需要调用 GitLab API 的操作节点中，我们会并排提供两种认证方式的字段：
        -   一个**非必填**的凭证选择框，用于选择预设的 `gitlabApi` 凭证。
        -   `Host` 和 `Access Token` 两个输入字段。

3.  **UI 显示逻辑**
    -   凭证选择框和 `Host`/`Access Token` 字段将始终在 UI 上可见。
    -   我们通过字段描述引导用户：如果选择了凭证，则无需填写 `Host` 和 `Access Token`；反之，则必须填写。

### 1.3 工作流执行逻辑

-   在节点的 `execute` 方法中，程序会优先尝试从节点的输入参数中获取 `Host` 和 `Access Token` 的值。
-   如果这两个字段有值，则使用它们进行认证。
-   如果这两个字段为空，程序会接着尝试加载用户选择的 `gitlabApi` 凭证。
-   如果在两种方式下都未能成功获取到 `host` 和 `accessToken`，节点将抛出一个明确的错误，提示用户必须提供有效的认证信息。
-   获取到认证信息后，再初始化 `@gitbeaker/rest` 的客户端实例，并执行后续的 API 调用。

通过这种方式，我们设计的节点将能够优雅、清晰地处理绝大多数使用场景。

## 2. 节点结构

为了保持代码的清晰度、可维护性和可扩展性，我们采用按资源分组的节点结构。

- **实现方案**: 为 GitLab 中每一种核心资源（如项目、分支、合并请求等）创建一个独立的 n8n 节点。
- **命名约定**: 节点将以 `GitLab` 为前缀，后跟资源名称，例如：
    - `GitLab Project`
    - `GitLab Merge Request`
    - `GitLab Branch`
    - `GitLab Commit`
- **内部操作**: 每个资源节点内部会包含一个 `operation` 字段（下拉菜单），用于选择具体的操作，如 `Create`, `Get`, `Update`, `Delete` 等。

这种结构使得每个节点的功能内聚，代码更易于管理。
